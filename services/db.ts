
import { supabase } from './supabaseClient';
import { 
    User, Product, Order, UserRole, 
    VisitLog, StockLog, Transaction, SupportTicket, 
    Review, CreditRequest, VisitRequest, TicketMessage, ProductVariant, ProductCategory, PaymentCategory
} from '../types';

// --- DATA MAPPERS ---

const mapDbVariantToApp = (v: any): ProductVariant => ({
    id: v.id,
    color: v.color,
    sizeRange: v.size_range,
    stock: v.stock,
    pricePerPiece: v.price_per_piece,
    piecesPerSet: v.pieces_per_set
});

const mapAppVariantToDb = (v: ProductVariant, productId: string) => {
    // If ID is temporary (generated by Date.now()), remove it to let DB generate UUID
    const isTempId = v.id.startsWith('v-') || v.id.length < 20;
    return {
        id: isTempId ? undefined : v.id,
        product_id: productId,
        color: v.color,
        size_range: v.sizeRange,
        stock: v.stock,
        price_per_piece: v.pricePerPiece,
        pieces_per_set: v.piecesPerSet
    };
};

const mapDbProductToApp = (p: any): Product => ({
    id: p.id,
    sku: p.sku,
    name: p.name,
    description: p.description,
    category: p.category as ProductCategory,
    fabric: p.fabric,
    basePrice: p.base_price,
    images: p.images || [],
    video: p.video,
    isAvailable: p.is_available,
    collection: p.collection,
    hsnCode: p.hsn_code,
    variants: (p.variants || []).map(mapDbVariantToApp),
    created_at: p.created_at
});

const mapAppProductToDb = (p: Partial<Product>) => {
    const dbP: any = { ...p };
    // Map camelCase to snake_case
    if (p.basePrice !== undefined) dbP.base_price = p.basePrice;
    if (p.isAvailable !== undefined) dbP.is_available = p.isAvailable;
    if (p.hsnCode !== undefined) dbP.hsn_code = p.hsnCode;
    
    // Remove app-specific fields not in products table
    delete dbP.basePrice;
    delete dbP.isAvailable;
    delete dbP.hsnCode;
    delete dbP.variants;
    
    // Remove temp IDs
    if (dbP.id && (dbP.id.startsWith('p-') || dbP.id.length < 20)) {
        delete dbP.id;
    }
    
    return dbP;
};

const mapDbOrderToAppOrder = (o: any): Order => ({
    id: o.id,
    userId: o.user_id,
    userBusinessName: o.user_business_name,
    userCity: o.user_city,
    userState: o.user_state,
    items: o.items || [], 
    totalAmount: o.total_amount,
    factoryAmount: o.factory_amount,
    guarantorId: o.guarantor_id,
    guarantorFee: o.guarantor_fee,
    status: o.status,
    createdAt: o.created_at,
    settlementDeadline: o.settlement_deadline,
    paymentDetails: {
        method: o.payment_method as PaymentCategory,
    },
    documents: o.documents,
    transport: o.transport_details,
    trackingNumber: o.tracking_number,
    gaddiId: o.gaddi_id,
    poNumber: o.po_number,
    poImageUrl: o.po_image_url
});

const mapAppOrderToDbOrder = (o: Partial<Order>): any => {
    const dbOrder: any = {};
    if (o.status) dbOrder.status = o.status;
    if (o.documents) dbOrder.documents = o.documents;
    if (o.transport) dbOrder.transport_details = o.transport;
    if (o.trackingNumber) dbOrder.tracking_number = o.trackingNumber;
    if (o.poNumber) dbOrder.po_number = o.poNumber;
    if (o.poImageUrl) dbOrder.po_image_url = o.poImageUrl;
    return dbOrder;
};

const mapProfileToUser = (p: any): User => ({
    id: p.id,
    email: p.email || '',
    fullName: p.full_name || '',
    businessName: p.business_name,
    role: p.role as UserRole,
    gstin: p.gstin,
    mobile: p.mobile,
    isApproved: p.is_approved,
    isPreBookApproved: p.is_pre_book_approved,
    creditLimit: p.credit_limit || 0,
    outstandingDues: p.outstanding_dues || 0,
    wishlist: p.wishlist || [],
    assignedAgentId: p.assigned_agent_id,
    gaddiId: p.gaddi_id,
    assignedDistributorId: p.assigned_distributor_id,
    address: p.address,
    city: p.city,
    state: p.state,
    created_at: p.created_at
});

// --- AI SERVICE WRAPPER ---
// All AI logic must go through Supabase Edge Functions to protect keys and control costs.
const invokeAiFunction = async <T>(functionName: string, payload: any): Promise<T> => {
    try {
        const { data, error } = await supabase.functions.invoke(functionName, {
            body: payload
        });

        if (error) {
            console.error(`AI Function Error (${functionName}):`, error);
            throw new Error("AI Service Unavailable");
        }

        return data as T;
    } catch (e) {
        // Fallback or rethrow depending on requirement
        throw e;
    }
};

// --- UTILITIES ---

export const getGeminiKey = (): string => {
    // Check process.env (Vite injects this if defined)
    if (process.env.API_KEY) return process.env.API_KEY;
    // Fallback to local storage for manual entry
    return localStorage.getItem('gemini_api_key') || '';
};

export const handleAiError = async (error: any): Promise<boolean> => {
    console.error("AI Error:", error);
    if (error.message?.includes("API key") || error.message?.includes("API_KEY")) {
        //alert("API Key invalid or missing. Please check Admin Settings.");
        return true;
    }
    return false;
};

export const parseAIJson = <T>(text: string, fallback: T): T => {
    try {
        // Clean markdown code blocks often returned by LLMs
        const clean = text.replace(/```json/g, '').replace(/```/g, '').trim();
        return JSON.parse(clean);
    } catch (e) {
        console.warn("JSON Parse failed for AI response", e);
        return fallback;
    }
};

export const runAiWithRetry = async <T>(fn: () => Promise<T>, retries = 3): Promise<T> => {
    let lastError;
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (e) {
            lastError = e;
            // Exponential backoff: 1s, 2s, 3s
            await new Promise(r => setTimeout(r, (i + 1) * 1000));
        }
    }
    throw lastError;
};

// --- DATABASE INTERFACE ---

export const db = {
    // --- AUTH METHODS ---
    signIn: async (email: string, password: string) => {
        try {
            const { data, error } = await supabase.auth.signInWithPassword({ email, password });
            return { user: data.user ? await db.getUserById(data.user.id) : null, error: error?.message };
        } catch(e: any) {
            return { user: null, error: e.message || "Connection failed" };
        }
    },

    signOut: async () => {
        await supabase.auth.signOut();
    },

    updatePassword: async (password: string) => {
        const { error } = await supabase.auth.updateUser({ password });
        return { success: !error, error: error?.message };
    },

    // --- PRODUCTS ---
    getProducts: async (): Promise<Product[]> => {
        try {
            const { data, error } = await supabase
                .from('products')
                .select('*, variants:product_variants(*)')
                .eq('is_available', true);
            
            if (error) {
                // Suppress 'permission denied' logs which are expected for guest users due to RLS
                if (!error.message.toLowerCase().includes('permission denied')) {
                    console.warn("DB Read Error (Products):", error.message);
                }
                return [];
            }
            return (data || []).map(mapDbProductToApp);
        } catch (e) {
            console.warn("Connection Error (Products):", e);
            return [];
        }
    },

    saveProduct: async (product: Partial<Product>): Promise<boolean> => {
        const dbProduct = mapAppProductToDb(product);
        
        const { data: savedProd, error } = await supabase
            .from('products')
            .upsert(dbProduct)
            .select()
            .single();

        if (error) {
            console.error("Save Product Error:", error);
            return false;
        }

        if (product.variants && savedProd) {
            const variantUpserts = product.variants.map(v => mapAppVariantToDb(v, savedProd.id));
            const { error: vError } = await supabase.from('product_variants').upsert(variantUpserts);
            if (vError) console.error("Save Variants Error:", vError);
        }

        return true;
    },

    deleteProduct: async (id: string): Promise<boolean> => {
        const { error } = await supabase.from('products').delete().eq('id', id);
        return !error;
    },

    // --- USERS ---
    getUsers: async (): Promise<User[]> => {
        try {
            const { data, error } = await supabase.from('profiles').select('*');
            if (error) throw error;
            return (data as any[]).map(mapProfileToUser);
        } catch(e) {
            console.warn("DB Read Error (Users)", e);
            return [];
        }
    },

    getUserById: async (id: string): Promise<User | null> => {
        try {
            const { data, error } = await supabase.from('profiles').select('*').eq('id', id).single();
            if (error || !data) return null;
            return mapProfileToUser(data);
        } catch(e) {
            return null;
        }
    },

    registerUser: async (user: User, password?: string): Promise<{ success: boolean; error?: string }> => {
        try {
            const { data, error } = await supabase.auth.signUp({
                email: user.email,
                password: password || 'TempPass123!',
                options: {
                    data: {
                        full_name: user.fullName,
                        role: user.role,
                        business_name: user.businessName
                    }
                }
            });

            if (error) return { success: false, error: error.message };
            
            // Profile creation is handled by Supabase Triggers (handle_new_user)
            // We update additional fields that might not be in the initial metadata map
            if (data.user) {
                const { error: updateError } = await supabase.from('profiles').update({
                    gstin: user.gstin,
                    mobile: user.mobile,
                    city: user.city,
                    state: user.state,
                    address: user.address,
                    assigned_agent_id: user.assignedAgentId,
                    gaddi_id: user.gaddiId
                }).eq('id', data.user.id);

                if (updateError) console.error("Profile update error", updateError);
                return { success: true };
            }
            return { success: false, error: "Registration failed unknown" };
        } catch (e: any) {
            return { success: false, error: e.message || "Network error during registration" };
        }
    },

    updateUser: async (user: User): Promise<boolean> => {
        const { error } = await supabase.from('profiles').update({
            full_name: user.fullName,
            business_name: user.businessName,
            mobile: user.mobile,
            gstin: user.gstin,
            credit_limit: user.creditLimit,
            outstanding_dues: user.outstandingDues,
            is_approved: user.isApproved,
            is_pre_book_approved: user.isPreBookApproved,
            wishlist: user.wishlist,
            gaddi_id: user.gaddiId,
            assigned_agent_id: user.assignedAgentId,
            assigned_distributor_id: user.assignedDistributorId
        }).eq('id', user.id);
        
        return !error;
    },

    // --- ORDERS ---
    createOrder: async (orderData: Partial<Order>): Promise<boolean> => {
        try {
            const { error } = await supabase.rpc('place_order', {
                p_user_id: orderData.userId,
                p_items: orderData.items?.map(i => ({
                    variant_id: i.variantId,
                    quantity_sets: i.quantitySets
                })),
                p_payment_method: orderData.paymentDetails?.method,
                p_guarantor_id: orderData.guarantorId
            });

            if (error) {
                console.error("Order RPC Error:", error);
                return false;
            }
            return true;
        } catch (e) {
            console.error("Order Exception:", e);
            return false;
        }
    },

    getAllOrders: async (): Promise<Order[]> => {
        try {
            const { data, error } = await supabase.from('orders').select('*').order('created_at', { ascending: false });
            if (error) return [];
            return data.map(mapDbOrderToAppOrder);
        } catch { return []; }
    },

    getOrdersByUser: async (userId: string): Promise<Order[]> => {
        try {
            const { data, error } = await supabase.from('orders').select('*').eq('user_id', userId).order('created_at', { ascending: false });
            if (error) return [];
            return data.map(mapDbOrderToAppOrder);
        } catch { return []; }
    },

    updateOrder: async (id: string, updates: Partial<Order>): Promise<boolean> => {
        const { error } = await supabase.from('orders').update(mapAppOrderToDbOrder(updates)).eq('id', id);
        return !error;
    },

    // --- STORAGE ---
    uploadImage: async (file: File, bucket = 'products'): Promise<string> => {
        const fileExt = file.name.split('.').pop();
        const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
        
        const { error: uploadError } = await supabase.storage
            .from(bucket)
            .upload(fileName, file, {
                cacheControl: '3600',
                upsert: false
            });

        if (uploadError) throw uploadError;

        const { data } = supabase.storage.from(bucket).getPublicUrl(fileName);
        return data.publicUrl;
    },

    uploadVideo: async (file: File): Promise<string> => {
        return db.uploadImage(file, 'videos');
    },

    uploadDocument: async (file: File): Promise<string> => {
        return db.uploadImage(file, 'documents');
    },

    // --- OTHER ENTITIES ---
    getTransactions: async (userId?: string): Promise<Transaction[]> => {
        let query = supabase.from('transactions').select('*').order('date', { ascending: false });
        if (userId) query = query.eq('user_id', userId);
        const { data, error } = await query;
        if (error) return [];
        return data.map(t => ({
            ...t,
            userId: t.user_id,
            referenceId: t.reference_id,
            createdBy: t.created_by
        }));
    },

    recordTransaction: async (tx: Transaction): Promise<boolean> => {
        const { error } = await supabase.from('transactions').insert({
            user_id: tx.userId,
            type: tx.type,
            amount: tx.amount,
            description: tx.description,
            reference_id: tx.referenceId,
            date: tx.date
        });
        return !error;
    },

    getVisitLogs: async (agentId?: string): Promise<VisitLog[]> => {
        let query = supabase.from('visit_logs').select('*');
        if (agentId) query = query.eq('agent_id', agentId);
        const { data, error } = await query;
        if (error) return [];
        return data.map(v => ({
            ...v,
            agentId: v.agent_id,
            clientId: v.client_id,
            clientName: v.client_name,
            amountCollected: v.amount_collected
        }));
    },

    logVisit: async (log: VisitLog): Promise<boolean> => {
        const { error } = await supabase.from('visit_logs').insert({
            agent_id: log.agentId,
            client_id: log.clientId,
            client_name: log.clientName,
            date: log.date,
            purpose: log.purpose,
            notes: log.notes,
            location: log.location,
            amount_collected: log.amountCollected
        });
        return !error;
    },

    getTickets: async (userId?: string): Promise<SupportTicket[]> => {
        try {
            let query = supabase.from('support_tickets').select('*');
            if (userId) query = query.eq('user_id', userId);
            const { data } = await query;
            if (!data) return [];
            return data.map(t => ({
                ...t,
                userId: t.user_id,
                userName: t.user_name,
                orderId: t.order_id,
                createdAt: t.created_at,
                updatedAt: t.updated_at
            }));
        } catch { return []; }
    },

    createTicket: async (ticket: SupportTicket): Promise<boolean> => {
        const { error } = await supabase.from('support_tickets').insert({
            user_id: ticket.userId,
            user_name: ticket.userName,
            subject: ticket.subject,
            category: ticket.category,
            status: ticket.status,
            priority: ticket.priority,
            messages: ticket.messages,
            order_id: ticket.orderId
        });
        return !error;
    },

    updateTicket: async (id: string, updates: Partial<SupportTicket>): Promise<boolean> => {
        const { error } = await supabase.from('support_tickets').update(updates).eq('id', id);
        return !error;
    },

    addTicketMessage: async (ticketId: string, message: TicketMessage): Promise<boolean> => {
        const { data } = await supabase.from('support_tickets').select('messages').eq('id', ticketId).single();
        if (!data) return false;
        
        const newMessages = [...(data.messages as any[] || []), message];
        const { error } = await supabase.from('support_tickets').update({ 
            messages: newMessages, 
            updated_at: new Date().toISOString() 
        }).eq('id', ticketId);
        
        return !error;
    },

    getStockLogs: async (): Promise<StockLog[]> => {
        try {
            const { data } = await supabase.from('stock_logs').select('*').order('date', { ascending: false });
            if (!data) return [];
            return data.map(l => ({
                ...l,
                productId: l.product_id,
                variantId: l.variant_id,
                productName: l.product_name,
                variantDesc: l.variant_desc,
                performedBy: l.performed_by
            }));
        } catch { return []; }
    },

    logStockMovement: async (log: StockLog): Promise<boolean> => {
        const { error } = await supabase.from('stock_logs').insert({
            product_id: log.productId,
            variant_id: log.variantId,
            product_name: log.productName,
            variant_desc: log.variantDesc,
            quantity: log.quantity,
            type: log.type,
            reason: log.reason,
            date: log.date,
            performed_by: log.performedBy
        });
        return !error;
    },

    getReviews: async (productId: string): Promise<Review[]> => {
        const { data } = await supabase.from('reviews').select('*').eq('product_id', productId);
        if (!data) return [];
        return data.map(r => ({
            ...r,
            productId: r.product_id,
            userId: r.user_id,
            userName: r.user_name,
            createdAt: r.created_at
        }));
    },

    addReview: async (review: Omit<Review, 'id' | 'createdAt'>): Promise<boolean> => {
        const { error } = await supabase.from('reviews').insert({
            product_id: review.productId,
            user_id: review.userId,
            user_name: review.userName,
            rating: review.rating,
            comment: review.comment
        });
        return !error;
    },

    getAdminDashboardData: async () => {
        try {
            const { count: userCount } = await supabase.from('profiles').select('*', { count: 'exact', head: true });
            const { count: orderCount } = await supabase.from('orders').select('*', { count: 'exact', head: true });
            const { count: pendingCount } = await supabase.from('orders').select('*', { count: 'exact', head: true }).eq('status', 'PENDING');
            const { data: recentOrders } = await supabase.from('orders').select('*').order('created_at', { ascending: false }).limit(5);

            return {
                orderCount: orderCount || 0,
                userCount: userCount || 0,
                pendingApprovals: pendingCount || 0,
                recentOrders: recentOrders ? recentOrders.map(mapDbOrderToAppOrder) : []
            };
        } catch (e) {
            return { orderCount: 0, userCount: 0, pendingApprovals: 0, recentOrders: [] };
        }
    },
    
    getVisitRequests: async (): Promise<VisitRequest[]> => {
        try {
            const { data } = await supabase.from('visit_requests').select('*');
            if (!data) return [];
            return data.map(v => ({
                ...v,
                userId: v.user_id,
                userName: v.user_name,
                requestedDate: v.requested_date,
                requestedTime: v.requested_time
            }));
        } catch { return []; }
    },

    createVisitRequest: async (req: Partial<VisitRequest>): Promise<boolean> => {
        const { error } = await supabase.from('visit_requests').insert({
            user_id: req.userId,
            user_name: req.userName,
            type: req.type,
            requested_date: req.requestedDate,
            requested_time: req.requestedTime,
            notes: req.notes
        });
        return !error;
    },

    updateVisitRequest: async (id: string, updates: Partial<VisitRequest>): Promise<boolean> => {
        const { error } = await supabase.from('visit_requests').update(updates).eq('id', id);
        return !error;
    },

    getCreditRequests: async (): Promise<CreditRequest[]> => {
        try {
            const { data } = await supabase.from('credit_requests').select('*');
            if (!data) return [];
            return data.map(c => ({
                ...c,
                userId: c.user_id,
                userName: c.user_name,
                currentLimit: c.current_limit,
                requestedLimit: c.requested_limit
            }));
        } catch { return []; }
    },

    processCreditRequest: async (id: string, status: 'APPROVED' | 'REJECTED'): Promise<boolean> => {
        const { error } = await supabase.rpc('process_credit_request', { p_request_id: id, p_status: status });
        return !error;
    },
    
    triggerSecurityLockout: async (userId: string, name: string, reason: string) => {
        await supabase.from('profiles').update({ 
            is_approved: false, 
            admin_notes: `SECURITY LOCKOUT: ${reason}` 
        }).eq('id', userId);
    },

    // --- AI GATEWAY ---
    ai: {
        generateContent: async (prompt: string): Promise<string> => {
            const res = await invokeAiFunction<{text: string}>('gemini-generate', { prompt });
            return res.text;
        },
        generateJson: async <T>(prompt: string): Promise<T> => {
            const res = await invokeAiFunction<{data: T}>('gemini-generate-json', { prompt });
            return res.data;
        },
        analyzeImage: async (base64Image: string, prompt: string): Promise<string> => {
            const res = await invokeAiFunction<{text: string}>('gemini-vision', { image: base64Image, prompt });
            return res.text;
        }
    }
};
